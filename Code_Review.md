# Code Review: Mini Scale (ESP8266 + HX711 + SSD1306)

---

## ОШИБКИ

### 1. Автовыключение игнорирует активность пользователя
> `Mini_Scale.ino.ino` : строка 50

```cpp
if (millis() > 180000) {
```

Таймер считается от момента включения и **никогда не сбрасывается**.
Даже если пользователь активно нажимает кнопки и взвешивает — весы выключатся
ровно через 3 минуты. Нужен сброс таймера при любой активности.

---

### 2. Сравнение `float` с нулём через `==`
> `Mini_Scale.ino.ino` : строка 34

```cpp
if (smoothed_bat_raw == 0) smoothed_bat_raw = current_bat_raw;
```

Прямое сравнение `float == 0` ненадёжно из-за особенностей хранения
чисел с плавающей точкой. Лучше использовать `< 0.001` или `bool`-флаг
первого чтения.

---

### 3. Некорректный расчёт напряжения батареи
> `Mini_Scale.ino.ino` : строка 39

```cpp
float bat_voltage = smoothed_bat_raw * (4.2 / 1023.0);
```

ESP8266 ADC работает в диапазоне **0–1V**. Формула предполагает, что при
4.2V АЦП даёт 1023, но это не так без учёта коэффициента делителя
напряжения. Результат будет **завышен**, проценты — некорректны.

---

### 4. `map()` принимает `float`, но работает с `long`
> `Mini_Scale.ino.ino` : строка 40

```cpp
int bat_percent = map(bat_voltage * 100, 320, 420, 0, 100);
```

`bat_voltage * 100` — это `float`, который неявно приводится к `long`
с потерей дробной части. Результат — скачки процентов на 1–2%.

---

### 5. Блокирующая обработка кнопки
> `ButtonControl.h` : строки 13–24

```cpp
while (digitalRead(BUTTON_PIN) == LOW) {
    ...
    delay(100);
}
```

Пока пользователь держит кнопку (до 10+ секунд для Undo Tare), весь `loop()`
заблокирован. Вес не обновляется, батарея не читается, автовыключение
не проверяется.

---

### 6. Весь код реализован в `.h` файлах
> `ButtonControl.h`, `CalibrationMode.h`, `DisplayControl.h`,
> `MemoryControl.h`, `ScaleControl.h`

Определения функций и глобальных переменных находятся в header-файлах.
Если любой `.h` будет подключён из двух `.cpp` — ошибка линковки
**multiple definition**. Работает только потому, что всё подключается
из единственного `.ino`.

---

### 7. Глобальные объекты в header-файлах без `extern`
> `DisplayControl.h:6` · `ScaleControl.h:5–7` · `MemoryControl.h:12–13`

```cpp
Adafruit_SSD1306 display(...);
HX711 scale;
EEPROM_Data savedData;
```

Объекты создаются прямо в заголовках. Порядок инициализации не гарантирован,
при расширении проекта — неизбежные проблемы.

---

### 8. Нет debounce при входе в калибровку
> `Mini_Scale.ino.ino` : строка 20

```cpp
if (digitalRead(BUTTON_PIN) == LOW) {
    RunCalibrationMode();
}
```

Единственное чтение без задержки на дребезг. Наводка или случайное
замыкание при старте может ложно перевести в режим калибровки.

---

### 9. Дублирование инициализации HX711
> `CalibrationMode.h` : строка 7

```cpp
scale.begin(DOUT_PIN, SCK_PIN);
```

`RunCalibrationMode()` вызывает `scale.begin()` сам, а `Scale_Init()`
делает то же самое. При изменении порядка вызовов — двойная инициализация.

---

### 10. `long` вместо `unsigned long` для `millis()`
> `ButtonControl.h:11` · `CalibrationMode.h:50`

```cpp
long pressTime = millis();
```

`millis()` возвращает `unsigned long`. Присвоение в `long` приведёт
к некорректным значениям после ~24.8 дня непрерывной работы.

---

### 11. Переполнение `millis()` не обработано
> `Mini_Scale.ino.ino:50` · `ButtonControl.h:11,26`

`millis()` переполняется через ~49 дней. Проверка `millis() > 180000`
вместо `millis() - lastActivity > 180000` не защищена от переполнения
(хотя для 3-минутного таймера это маловероятная ситуация).

---

## УЛУЧШЕНИЯ

### 1. Сброс таймера автовыключения при активности

Сохранять `lastActivityTime = millis()` при нажатии кнопки или изменении
веса. Проверять `millis() - lastActivityTime > 180000` вместо абсолютного
сравнения.

---

### 2. Неблокирующая обработка кнопки (state machine)

Заменить `while`-цикл ожидания отпускания кнопки на конечный автомат,
который проверяет состояние на каждой итерации `loop()`. Это позволит
продолжать обновлять вес и батарею во время удержания.

---

### 3. Фильтрация показаний веса

`Scale_Update()` берёт единственное чтение — `get_units(1)`.
Показания будут прыгать. Нужно скользящее среднее (как для батареи)
или увеличить число чтений до `get_units(3)`.

---

### 4. Нелинейный расчёт процента батареи

Линейная интерполяция `map()` между 3.2V и 4.2V неточна —
разряд Li-Ion **нелинеен**. Lookup-таблица напряжение/процент даст
реалистичные показания.

---

### 5. Индикация низкого заряда

Если `bat_percent < 10%` — показать предупреждение на дисплее.
Сейчас пользователь не узнает о разряде, пока весы не выключатся.

---

### 6. Переменный шаг калибровки

Шаг фиксирован: `+10` / `-10`. Для точной настройки нужен
дополнительный режим с шагом `+1` / `-1`.

---

### 7. Разделить `.h` и `.cpp`

Перенести реализацию функций в `.cpp` файлы, оставив в `.h`
только объявления — стандартная практика C++.

---

### 8. Отображать ошибку HX711 на дисплее

Сейчас если HX711 не найден при старте, сообщение идёт только
в Serial. Пользователь без компьютера его не увидит. Показывать
ошибку на дисплее.

---

### 9. Сохранять вес перед автовыключением

Перед `deepSleep` вызвать:
```cpp
savedData.last_weight = current_weight;
Memory_Save();
```
Иначе дельта при следующем включении будет считаться от устаревшего
значения.

---

### 10. Таймаут / выход без сохранения в режиме калибровки

`while(true)` — бесконечный цикл без выхода. Если пользователь
случайно зашёл в калибровку — единственный способ выйти —
физическая перезагрузка. Нужен пункт меню «Exit without save»
или автовыход по таймауту.

---

### 11. Контроль износа EEPROM

`Memory_Save()` вызывается при каждом тарировании и при каждом старте.
Ресурс EEPROM ESP8266 — ~100 000 циклов. Стоит минимизировать записи
или использовать ротацию адресов (wear leveling).

---

### 12. Программный debounce для кнопки

Ни в `Button_Check()`, ни при входе в калибровку нет устранения
дребезга контактов. Фильтр 20–50 мс после обнаружения нажатия
устранит ложные срабатывания.

---

> **Итого:** 11 ошибок, 12 рекомендаций по улучшению.
